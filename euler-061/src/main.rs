/*
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

+--------------------+--------------------+---------------------+
|Triangle            |P(3,n) = n(n+1)/2   |1, 3, 6, 10, 15, ... |
+--------------------+--------------------+---------------------+
|Square              |P(4,n) = n2         |1, 4, 9, 16, 25, ... |
+--------------------+--------------------+---------------------+
|Pentagonal          |P(5,n) = n(3n−1)/2  |1, 5, 12, 22, 35, ...|
+--------------------+--------------------+---------------------+
|Hexagonal           |P(6,n) = n(2n−1)    |1, 6, 15, 28, 45, ...|
+--------------------+--------------------+---------------------+
|Heptagonal          |P(7,n) = n(5n−3)/2  |1, 7, 18, 34, 55, ...|
+--------------------+--------------------+---------------------+
|Octagonal           |P(8,n) = n(3n−2)    |1, 8, 21, 40, 65, ...|
+--------------------+--------------------+---------------------+

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

1. The set is cyclic, in that the last two digits of each number is the first
two digits of the next number (including the last number with the first).
2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
pentagonal (P5,44=2882), is represented by a different number in the set.
3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.
*/

use lazy_static::lazy_static;

type Num = usize;

const BASE: u8 = 10;
const BASE_NUM: Num = BASE as Num;
const NUM_DIGITS: usize = 4;
lazy_static! {
    static ref MIN_NUM: Num = int_pow(BASE_NUM, NUM_DIGITS - 1);
    static ref MAX_NUM: Num = int_pow(BASE_NUM, NUM_DIGITS);
}

fn main() {
    const NUM: Num = 5;
    let triangles = (1..=NUM).map(triangle_num).collect::<Vec<_>>();
    let squares = (1..=NUM).map(square_num).collect::<Vec<_>>();
    let pentagons = (1..=NUM).map(pentagonal_num).collect::<Vec<_>>();
    let hexagons = (1..=NUM).map(hexagonal_num).collect::<Vec<_>>();
    let heptagons = (1..=NUM).map(heptagonal_num).collect::<Vec<_>>();
    let octagons = (1..=NUM).map(octagonal_num).collect::<Vec<_>>();
    println!(
        "{:?}\n{:?}\n{:?}\n{:?}\n{:?}\n{:?}",
        triangles, squares, pentagons, hexagons, heptagons, octagons
    );
}

fn get_digits(x: Num) -> Option<[u8; NUM_DIGITS]> {
    if x < *MIN_NUM || x >= *MAX_NUM {
        return None;
    }
    let mut digits = [0; NUM_DIGITS];
    let mut cur_base = 1;
    for index in 0..NUM_DIGITS {
        let next_base = cur_base * BASE_NUM;
        let digit = (x % next_base) / cur_base;
        digits[index] = digit as u8;
        cur_base = next_base;
    }
    Some(digits)
}

fn int_pow(base: Num, power: Num) -> Num {
    (0..power).fold(1, |result, _| result * base)
}

fn triangle_num(n: Num) -> Num {
    n * (n + 1) / 2
}

fn square_num(n: Num) -> Num {
    n * n
}

fn pentagonal_num(n: Num) -> Num {
    n * (3 * n - 1) / 2
}

fn hexagonal_num(n: Num) -> Num {
    n * (2 * n - 1)
}

fn heptagonal_num(n: Num) -> Num {
    n * (5 * n - 3) / 2
}

fn octagonal_num(n: Num) -> Num {
    n * (3 * n - 2)
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_int_pow_special_case_zero_to_the_zero() {
        assert_eq!(int_pow(0, 0), 1);
    }

    #[test]
    fn test_int_pow_base_zero() {
        for power in 1..4 {
            assert_eq!(int_pow(0, power), 0);
        }
    }

    #[test]
    fn test_int_pow_power_zero() {
        for base in 0..4 {
            assert_eq!(int_pow(base, 0), 1);
        }
    }

    #[test]
    fn test_int_pow_base_one() {
        for power in 0..4 {
            assert_eq!(int_pow(1, power), 1);
        }
    }

    #[test]
    fn test_int_pow_power_one() {
        for base in 0..4 {
            assert_eq!(int_pow(base, 1), base);
        }
    }

    #[test]
    fn test_int_pow_normal() {
        let test_cases = [
            (2, 2, 4),
            (2, 3, 8),
            (2, 4, 16),
            (3, 2, 9),
            (3, 3, 27),
            (3, 4, 81),
        ];
        for &(base, power, result) in test_cases.iter() {
            assert_eq!(int_pow(base, power), result);
        }
    }

    #[test]
    fn test_get_digits() {
        let test_cases = [
            (1234, [4, 3, 2, 1]),
            (2345, [5, 4, 3, 2]),
            (7890, [0, 9, 8, 7]),
            (8103, [3, 0, 1, 8]),
        ];
        for &(num, digits) in test_cases.iter() {
            assert_eq!(get_digits(num), Some(digits));
        }
    }

    #[test]
    fn test_get_digits_bad_nums() {
        let bad_nums = [0, 1, 10, 99, 101, 999, 10000, 10001, 99999];
        for &num in bad_nums.iter() {
            assert!(get_digits(num).is_none());
        }
    }
}
