/*
Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:

2^2=4, 2^3=8, 2^4=16, 2^5=32
3^2=9, 3^3=27, 3^4=81, 3^5=243
4^2=16, 4^3=64, 4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the
following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and
2 ≤ b ≤ 100?
*/

use num_bigint::BigUint;
use num_traits::Pow;
use std::collections::HashSet;

const A_RANGE: (u64, u64) = (2, 100);
const B_RANGE: (u32, u32) = (2, 100);

fn main() {
    println!("{}", num_distinct_terms(A_RANGE, B_RANGE));
}

fn num_distinct_terms(a_range: (u64, u64), b_range: (u32, u32)) -> usize {
    distinct_terms(a_range, b_range).len()
}

fn distinct_terms((min_a, max_a): (u64, u64), (min_b, max_b): (u32, u32)) -> HashSet<BigUint> {
    (min_a..=max_a)
        .flat_map(move |a| (min_b..=max_b).map(move |b| (a, b)))
        .map(|(a, b)| BigUint::from(a).pow(b))
        .collect()
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn example() {
        assert_eq!(num_distinct_terms((2, 5), (2, 5)), 15);
    }

    #[test]
    fn answer() {
        assert_eq!(num_distinct_terms(A_RANGE, B_RANGE), 9183);
    }
}
